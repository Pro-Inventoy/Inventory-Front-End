{"ast":null,"code":"'use strict';\n\nvar assert = require('assert').ok;\n\nvar zlib = require('zlib');\n\nvar util = require('util');\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts); // Node 8 --> 9 compatibility check\n\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  } // Caller may invoke .close after a zlib error (which will null _handle).\n\n\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n  var buffers = [];\n  var nread = 0;\n  var error;\n  this.on('error', function (err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n\n  do {\n    var res = this._handle.writeSync(flushFlag, chunk, // in\n    inOff, // in_off\n    availInBefore, // in_len\n    this._buffer, // out\n    this._offset, //out_off\n    availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n\n\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;","map":{"version":3,"names":["assert","require","ok","zlib","util","kMaxLength","Inflate","opts","chunkSize","Z_MIN_CHUNK","call","_offset","undefined","_outOffset","_buffer","_outBuffer","maxLength","_maxLength","createInflate","_close","engine","callback","process","nextTick","_handle","close","prototype","_processChunk","chunk","flushFlag","asyncCb","self","availInBefore","length","availOutBefore","_chunkSize","leftToInflate","inOff","buffers","nread","error","on","err","handleChunk","availInAfter","availOutAfter","_hadError","have","out","slice","push","Buffer","allocUnsafe","res","writeSync","_writeState","RangeError","toString","buf","concat","inherits","zlibBufferSync","buffer","from","TypeError","_finishFlushFlag","Z_FINISH","inflateSync","module","exports"],"sources":["C:/Users/khaym/Desktop/finalproject/Inventory-Front-End/node_modules/pngjs/lib/sync-inflate.js"],"sourcesContent":["'use strict';\n\nvar assert = require('assert').ok;\nvar zlib = require('zlib');\nvar util = require('util');\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n\n  var buffers = [];\n  var nread = 0;\n\n  var error;\n  this.on('error', function(err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  do {\n    var res = this._handle.writeSync(flushFlag,\n      chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}