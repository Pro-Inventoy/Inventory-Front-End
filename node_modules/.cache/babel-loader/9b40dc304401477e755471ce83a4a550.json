{"ast":null,"code":"\"use strict\"; // JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {\n  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n  this.colorChannels = blendAlpha ? 4 : 3;\n  this.interpolationPass = Boolean(interpolationPass);\n  this.resizeCallback = typeof resizeCallback === 'function' ? resizeCallback : function () {};\n  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;\n  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;\n  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;\n  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;\n  this.initialize();\n}\n\nResize.prototype.initialize = function () {\n  // Perform some checks:\n  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {\n    this.configurePasses();\n  } else {\n    throw new Error('Invalid settings specified for the resizer.');\n  }\n};\n\nResize.prototype.configurePasses = function () {\n  if (this.widthOriginal === this.targetWidth) {\n    // Bypass the width resizer pass:\n    this.resizeWidth = this.bypassResizer;\n  } else {\n    // Setup the width resizer pass:\n    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n\n    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n      this.initializeFirstPassBuffers(true);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;\n    } else {\n      this.initializeFirstPassBuffers(false);\n      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n    }\n  }\n\n  if (this.heightOriginal === this.targetHeight) {\n    // Bypass the height resizer pass:\n    this.resizeHeight = this.bypassResizer;\n  } else {\n    // Setup the height resizer pass:\n    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n\n    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n      this.initializeSecondPassBuffers(true);\n      this.resizeHeight = this.resizeHeightInterpolated;\n    } else {\n      this.initializeSecondPassBuffers(false);\n      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n    }\n  }\n};\n\nResize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {\n  var channelsNum = fourthChannel ? 4 : 3;\n  var ratioWeight = this.ratioWeightWidthPass;\n  var outputBuffer = this.widthBuffer;\n  var weight = 0;\n  var finalOffset = 0;\n  var pixelOffset = 0;\n  var firstWeight = 0;\n  var secondWeight = 0;\n  var targetPosition; // Handle for only one interpolation input being valid for start calculation:\n\n  for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {\n    for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  } // Adjust for overshoot of the last pass's counter:\n\n\n  weight -= 1 / 3;\n  var interpolationWidthSourceReadStop;\n\n  for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight; // Interpolate:\n\n    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;\n    }\n  } // Handle for only one interpolation input being valid for end calculation:\n\n\n  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {\n    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel) outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {\n  var channelsNum = fourthChannel ? 4 : 3;\n  var ratioWeight = this.ratioWeightWidthPass;\n  var ratioWeightDivisor = 1 / ratioWeight;\n  var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;\n  var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;\n  var output = this.outputWidthWorkBench;\n  var outputBuffer = this.widthBuffer;\n  var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n  var weight = 0;\n  var amountToNext = 0;\n  var actualPosition = 0;\n  var currentPosition = 0;\n  var line = 0;\n  var pixelOffset = 0;\n  var outputOffset = 0;\n  var multiplier = 1;\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  var a = 0;\n\n  do {\n    for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n      output[line++] = 0;\n      output[line++] = 0;\n      output[line++] = 0;\n\n      if (fourthChannel) {\n        output[line++] = 0;\n        trustworthyColorsCount[line / channelsNum - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n\n      for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n        r = buffer[pixelOffset];\n        g = buffer[++pixelOffset];\n        b = buffer[++pixelOffset];\n        a = fourthChannel ? buffer[++pixelOffset] : 255; // Ignore RGB values if pixel is completely transparent\n\n        output[line++] += (a ? r : 0) * multiplier;\n        output[line++] += (a ? g : 0) * multiplier;\n        output[line++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[line++] += a * multiplier;\n          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition += channelsNum;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);\n\n    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      if (fourthChannel) outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n    }\n\n    outputOffset += channelsNum;\n  } while (outputOffset < this.targetWidthMultipliedByChannels);\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {\n  var ratioWeight = this.ratioWeightHeightPass;\n  var ratioWeightDivisor = 1 / ratioWeight;\n  var output = this.outputHeightWorkBench;\n  var outputBuffer = this.heightBuffer;\n  var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n  var weight = 0;\n  var amountToNext = 0;\n  var actualPosition = 0;\n  var currentPosition = 0;\n  var pixelOffset = 0;\n  var outputOffset = 0;\n  var caret = 0;\n  var multiplier = 1;\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  var a = 0;\n\n  do {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n\n      if (fourthChannel) {\n        output[pixelOffset++] = 0;\n        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      caret = actualPosition;\n\n      for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n        r = buffer[caret++];\n        g = buffer[caret++];\n        b = buffer[caret++];\n        a = fourthChannel ? buffer[caret++] : 255; // Ignore RGB values if pixel is completely transparent\n\n        output[pixelOffset++] += (a ? r : 0) * multiplier;\n        output[pixelOffset++] += (a ? g : 0) * multiplier;\n        output[pixelOffset++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[pixelOffset++] += a * multiplier;\n          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition = caret;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.widthPassResultSize);\n\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n\n      if (fourthChannel) {\n        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n      }\n    }\n  } while (outputOffset < this.finalResultSize);\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeWidthInterpolatedRGB = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeWidthRGB = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthRGBA = function (buffer) {\n  return this._resizeWidthRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeHeightInterpolated = function (buffer) {\n  var ratioWeight = this.ratioWeightHeightPass;\n  var outputBuffer = this.heightBuffer;\n  var weight = 0;\n  var finalOffset = 0;\n  var pixelOffset = 0;\n  var pixelOffsetAccumulated = 0;\n  var pixelOffsetAccumulated2 = 0;\n  var firstWeight = 0;\n  var secondWeight = 0;\n  var interpolationHeightSourceReadStop; // Handle for only one interpolation input being valid for start calculation:\n\n  for (; weight < 1 / 3; weight += ratioWeight) {\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n    }\n  } // Adjust for overshoot of the last pass's counter:\n\n\n  weight -= 1 / 3;\n\n  for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight; // Interpolate:\n\n    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;\n    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n\n    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);\n    }\n  } // Handle for only one interpolation input being valid for end calculation:\n\n\n  while (finalOffset < this.finalResultSize) {\n    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeHeightRGB = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeHeightRGBA = function (buffer) {\n  return this._resizeHeightRGBChannels(buffer, true);\n};\n\nResize.prototype.resize = function (buffer) {\n  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\n\nResize.prototype.bypassResizer = function (buffer) {\n  // Just return the buffer passed:\n  return buffer;\n};\n\nResize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal width pass buffers:\n  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);\n\n    if (this.colorChannels > 3) {\n      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);\n    }\n  }\n};\n\nResize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {\n  // Initialize the internal height pass buffers:\n  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);\n\n    if (this.colorChannels > 3) {\n      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);\n    }\n  }\n};\n\nResize.prototype.generateFloatBuffer = function (bufferLength) {\n  // Generate a float32 typed array buffer:\n  try {\n    return new Float32Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateFloat64Buffer = function (bufferLength) {\n  // Generate a float64 typed array buffer:\n  try {\n    return new Float64Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateUint8Buffer = function (bufferLength) {\n  // Generate a uint8 typed array buffer:\n  try {\n    return new Uint8Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nmodule.exports = Resize;","map":{"version":3,"mappings":"cAAA;AACA;;AAEA,SAASA,MAAT,CACEC,aADF,EAEEC,cAFF,EAGEC,WAHF,EAIEC,YAJF,EAKEC,UALF,EAMEC,iBANF,EAOEC,cAPF,EAQE;EACA,KAAKN,aAAL,GAAqBO,IAAI,CAACC,GAALD,CAASA,IAAI,CAACE,KAALF,CAAWP,aAAXO,KAA6B,CAAtCA,CAArB;EACA,KAAKN,cAAL,GAAsBM,IAAI,CAACC,GAALD,CAASA,IAAI,CAACE,KAALF,CAAWN,cAAXM,KAA8B,CAAvCA,CAAtB;EACA,KAAKL,WAAL,GAAmBK,IAAI,CAACC,GAALD,CAASA,IAAI,CAACE,KAALF,CAAWL,WAAXK,KAA2B,CAApCA,CAAnB;EACA,KAAKJ,YAAL,GAAoBI,IAAI,CAACC,GAALD,CAASA,IAAI,CAACE,KAALF,CAAWJ,YAAXI,KAA4B,CAArCA,CAApB;EACA,KAAKG,aAAL,GAAqBN,UAAU,GAAG,CAAH,GAAO,CAAtC;EACA,KAAKC,iBAAL,GAAyBM,OAAO,CAACN,iBAAD,CAAhC;EACA,KAAKC,cAAL,GACE,OAAOA,cAAP,KAA0B,UAA1B,GAAuCA,cAAvC,GAAwD,YAAW,CADrE;EAGA,KAAKM,+BAAL,GAAuC,KAAKV,WAAL,GAAmB,KAAKQ,aAA/D;EACA,KAAKG,iCAAL,GACE,KAAKb,aAAL,GAAqB,KAAKU,aAD5B;EAEA,KAAKI,kCAAL,GACE,KAAKb,cAAL,GAAsB,KAAKS,aAD7B;EAEA,KAAKK,mBAAL,GACE,KAAKH,+BAAL,GAAuC,KAAKX,cAD9C;EAEA,KAAKe,eAAL,GACE,KAAKJ,+BAAL,GAAuC,KAAKT,YAD9C;EAEA,KAAKc,UAAL;AACD;;AAEDlB,MAAM,CAACmB,SAAPnB,CAAiBkB,UAAjBlB,GAA8B,YAAW;EACvC;EACA,IACE,KAAKC,aAAL,GAAqB,CAArB,IACA,KAAKC,cAAL,GAAsB,CADtB,IAEA,KAAKC,WAAL,GAAmB,CAFnB,IAGA,KAAKC,YAAL,GAAoB,CAJtB,EAKE;IACA,KAAKgB,eAAL;EANF,OAOO;IACL,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;EACD;AAXH;;AAcArB,MAAM,CAACmB,SAAPnB,CAAiBoB,eAAjBpB,GAAmC,YAAW;EAC5C,IAAI,KAAKC,aAAL,KAAuB,KAAKE,WAAhC,EAA6C;IAC3C;IACA,KAAKmB,WAAL,GAAmB,KAAKC,aAAxB;EAFF,OAGO;IACL;IACA,KAAKC,oBAAL,GAA4B,KAAKvB,aAAL,GAAqB,KAAKE,WAAtD;;IACA,IAAI,KAAKqB,oBAAL,GAA4B,CAA5B,IAAiC,KAAKlB,iBAA1C,EAA6D;MAC3D,KAAKmB,0BAAL,CAAgC,IAAhC;MACA,KAAKH,WAAL,GACE,KAAKX,aAAL,KAAuB,CAAvB,GACI,KAAKe,2BADT,GAEI,KAAKC,0BAHX;IAFF,OAMO;MACL,KAAKF,0BAAL,CAAgC,KAAhC;MACA,KAAKH,WAAL,GACE,KAAKX,aAAL,KAAuB,CAAvB,GAA2B,KAAKiB,eAAhC,GAAkD,KAAKC,cADzD;IAED;EACF;;EAED,IAAI,KAAK3B,cAAL,KAAwB,KAAKE,YAAjC,EAA+C;IAC7C;IACA,KAAK0B,YAAL,GAAoB,KAAKP,aAAzB;EAFF,OAGO;IACL;IACA,KAAKQ,qBAAL,GAA6B,KAAK7B,cAAL,GAAsB,KAAKE,YAAxD;;IACA,IAAI,KAAK2B,qBAAL,GAA6B,CAA7B,IAAkC,KAAKzB,iBAA3C,EAA8D;MAC5D,KAAK0B,2BAAL,CAAiC,IAAjC;MACA,KAAKF,YAAL,GAAoB,KAAKG,wBAAzB;IAFF,OAGO;MACL,KAAKD,2BAAL,CAAiC,KAAjC;MACA,KAAKF,YAAL,GACE,KAAKnB,aAAL,KAAuB,CAAvB,GAA2B,KAAKuB,gBAAhC,GAAmD,KAAKC,eAD1D;IAED;EACF;AAlCH;;AAqCAnC,MAAM,CAACmB,SAAPnB,CAAiBoC,mCAAjBpC,GAAuD,UACrDqC,MADqD,EAErDC,aAFqD,EAGrD;EACA,IAAMC,WAAW,GAAGD,aAAa,GAAG,CAAH,GAAO,CAAxC;EACA,IAAME,WAAW,GAAG,KAAKhB,oBAAzB;EACA,IAAMiB,YAAY,GAAG,KAAKC,WAA1B;EAEA,IAAIC,MAAM,GAAG,CAAb;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAIC,YAAY,GAAG,CAAnB;EACA,IAAIC,cAAJ,CAVA,CAYA;;EACA,KACEA,cAAc,GAAG,CADnB,EAEEL,MAAM,GAAG,IAAI,CAFf,EAGEK,cAAc,IAAIT,WAAlBS,EAA+BL,MAAM,IAAIH,WAH3C,EAIE;IACA,KACEI,WAAW,GAAGI,cAAdJ,EAA8BC,WAAW,GAAG,CAD9C,EAEED,WAAW,GAAG,KAAK5B,mBAFrB,EAGE6B,WAAW,IAAI,KAAK/B,iCAApB+B,EACED,WAAW,IAAI,KAAK/B,+BAJxB,EAKE;MACA4B,YAAY,CAACG,WAAD,CAAZH,GAA4BJ,MAAM,CAACQ,WAAD,CAAlCJ;MACAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;MACAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;MACA,IAAIH,aAAJ,EACEG,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;IACH;EA7BH,EAgCA;;;EACAE,MAAM,IAAI,IAAI,CAAdA;EACA,IAAIM,gCAAJ;;EAEA,KACEA,gCAAgC,GAAG,KAAKhD,aAAL,GAAqB,CAD1D,EAEE0C,MAAM,GAAGM,gCAFX,EAGED,cAAc,IAAIT,WAAlBS,EAA+BL,MAAM,IAAIH,WAH3C,EAIE;IACA;IACAO,YAAY,GAAGJ,MAAM,GAAG,CAAxBI;IACAD,WAAW,GAAG,IAAIC,YAAlBD,CAHA,CAIA;;IACA,KACEF,WAAW,GAAGI,cAAdJ,EACEC,WAAW,GAAGrC,IAAI,CAACE,KAALF,CAAWmC,MAAXnC,IAAqB+B,WAFvC,EAGEK,WAAW,GAAG,KAAK5B,mBAHrB,EAIE6B,WAAW,IAAI,KAAK/B,iCAApB+B,EACED,WAAW,IAAI,KAAK/B,+BALxB,EAME;MACA4B,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GACEJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAANR,GAA0BS,WAA1BT,GACAA,MAAM,CAACQ,WAAW,GAAGN,WAAdM,GAA4B,CAA7B,CAANR,GAAwCU,YAF1CN;MAGAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GACEJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAANR,GAA0BS,WAA1BT,GACAA,MAAM,CAACQ,WAAW,GAAGN,WAAdM,GAA4B,CAA7B,CAANR,GAAwCU,YAF1CN;MAGAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GACEJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAANR,GAA0BS,WAA1BT,GACAA,MAAM,CAACQ,WAAW,GAAGN,WAAdM,GAA4B,CAA7B,CAANR,GAAwCU,YAF1CN;MAGA,IAAIH,aAAJ,EACEG,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GACEJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAANR,GAA0BS,WAA1BT,GACAA,MAAM,CAACQ,WAAW,GAAGN,WAAdM,GAA4B,CAA7B,CAANR,GAAwCU,YAF1CN;IAGH;EAjEH,EAoEA;;;EACA,KACEQ,gCAAgC,GAC9B,KAAKnC,iCAAL,GAAyCyB,WAF7C,EAGES,cAAc,GAAG,KAAKnC,+BAHxB,EAIEmC,cAAc,IAAIT,WAJpB,EAKE;IACA,KACEK,WAAW,GAAGI,cAAdJ,EACEC,WAAW,GAAGI,gCAFlB,EAGEL,WAAW,GAAG,KAAK5B,mBAHrB,EAIE6B,WAAW,IAAI,KAAK/B,iCAApB+B,EACED,WAAW,IAAI,KAAK/B,+BALxB,EAME;MACA4B,YAAY,CAACG,WAAD,CAAZH,GAA4BJ,MAAM,CAACQ,WAAD,CAAlCJ;MACAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;MACAA,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;MACA,IAAIH,aAAJ,EACEG,YAAY,CAACG,WAAW,GAAG,CAAf,CAAZH,GAAgCJ,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAtCJ;IACH;EACF;;EAED,OAAOA,YAAP;AA7FF;;AAgGAzC,MAAM,CAACmB,SAAPnB,CAAiBkD,uBAAjBlD,GAA2C,UAASqC,MAAT,EAAiBC,aAAjB,EAAgC;EACzE,IAAMC,WAAW,GAAGD,aAAa,GAAG,CAAH,GAAO,CAAxC;EACA,IAAME,WAAW,GAAG,KAAKhB,oBAAzB;EACA,IAAM2B,kBAAkB,GAAG,IAAIX,WAA/B;EACA,IAAMY,2BAA2B,GAC/B,KAAKtC,iCAAL,GAAyCyB,WAAzC,GAAuD,CADzD;EAEA,IAAMc,yBAAyB,GAC7B,KAAKxC,+BAAL,GAAuC0B,WAAvC,GAAqD,CADvD;EAEA,IAAMe,MAAM,GAAG,KAAKC,oBAApB;EACA,IAAMd,YAAY,GAAG,KAAKC,WAA1B;EACA,IAAMc,sBAAsB,GAAG,KAAKC,qCAApC;EAEA,IAAId,MAAM,GAAG,CAAb;EACA,IAAIe,YAAY,GAAG,CAAnB;EACA,IAAIC,cAAc,GAAG,CAArB;EACA,IAAIC,eAAe,GAAG,CAAtB;EACA,IAAIC,IAAI,GAAG,CAAX;EACA,IAAIhB,WAAW,GAAG,CAAlB;EACA,IAAIiB,YAAY,GAAG,CAAnB;EACA,IAAIC,UAAU,GAAG,CAAjB;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;;EAEA,GAAG;IACD,KAAKN,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAG,KAAK9C,kCAA3B,GAAiE;MAC/DuC,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiB,CAAjBA;MACAA,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiB,CAAjBA;MACAA,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiB,CAAjBA;;MACA,IAAIhB,aAAJ,EAAmB;QACjBgB,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiB,CAAjBA;QACAE,sBAAsB,CAACK,IAAI,GAAGtB,WAAPsB,GAAqB,CAAtB,CAAtBL,GAAiD,CAAjDA;MACD;IACF;;IAEDb,MAAM,GAAGH,WAATG;;IAEA,GAAG;MACDe,YAAY,GAAG,IAAIC,cAAJ,GAAqBC,eAApCF;MACAK,UAAU,GAAGvD,IAAI,CAAC4D,GAAL5D,CAASmC,MAATnC,EAAiBkD,YAAjBlD,CAAbuD;;MACA,KACEF,IAAI,GAAG,CAAPA,EAAUhB,WAAW,GAAGc,cAD1B,EAEEE,IAAI,GAAG,KAAK9C,kCAFd,EAGE8B,WAAW,IAAIO,2BAHjB,EAIE;QACAY,CAAC,GAAG3B,MAAM,CAACQ,WAAD,CAAVmB;QACAC,CAAC,GAAG5B,MAAM,CAAC,EAAEQ,WAAH,CAAVoB;QACAC,CAAC,GAAG7B,MAAM,CAAC,EAAEQ,WAAH,CAAVqB;QACAC,CAAC,GAAG7B,aAAa,GAAGD,MAAM,CAAC,EAAEQ,WAAH,CAAT,GAA2B,GAA5CsB,CAJA,CAKA;;QACAb,MAAM,CAACO,IAAI,EAAL,CAANP,IAAkB,CAACa,CAAC,GAAGH,CAAH,GAAO,CAAT,IAAcD,UAAhCT;QACAA,MAAM,CAACO,IAAI,EAAL,CAANP,IAAkB,CAACa,CAAC,GAAGF,CAAH,GAAO,CAAT,IAAcF,UAAhCT;QACAA,MAAM,CAACO,IAAI,EAAL,CAANP,IAAkB,CAACa,CAAC,GAAGD,CAAH,GAAO,CAAT,IAAcH,UAAhCT;;QACA,IAAIhB,aAAJ,EAAmB;UACjBgB,MAAM,CAACO,IAAI,EAAL,CAANP,IAAkBa,CAAC,GAAGJ,UAAtBT;UACAE,sBAAsB,CAACK,IAAI,GAAGtB,WAAPsB,GAAqB,CAAtB,CAAtBL,IAAkDW,CAAC,GAAGJ,UAAH,GAAgB,CAAnEP;QACD;MACF;;MAED,IAAIb,MAAM,IAAIe,YAAd,EAA4B;QAC1BC,cAAc,IAAIpB,WAAlBoB;QACAC,eAAe,GAAGD,cAAlBC;QACAjB,MAAM,IAAIe,YAAVf;MAHF,OAIO;QACLiB,eAAe,IAAIjB,MAAnBiB;QACA;MACD;IA7BH,SA+BEjB,MAAM,GAAG,CAATA,IACAgB,cAAc,GAAG,KAAK7C,iCAhCxB;;IAmCA,KACE+C,IAAI,GAAG,CAAPA,EAAUhB,WAAW,GAAGiB,YAD1B,EAEED,IAAI,GAAG,KAAK9C,kCAFd,EAGE8B,WAAW,IAAIQ,yBAHjB,EAIE;MACAV,MAAM,GAAGL,aAAa,GAAGkB,sBAAsB,CAACK,IAAI,GAAGtB,WAAR,CAAzB,GAAgD,CAAtEI;MACAoB,UAAU,GAAGzB,aAAa,GACtBK,MAAM,GACJ,IAAIA,MADA,GAEJ,CAHoB,GAItBQ,kBAJJY;MAKAtB,YAAY,CAACI,WAAD,CAAZJ,GAA4Ba,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiBS,UAA7CtB;MACAA,YAAY,CAAC,EAAEI,WAAH,CAAZJ,GAA8Ba,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiBS,UAA/CtB;MACAA,YAAY,CAAC,EAAEI,WAAH,CAAZJ,GAA8Ba,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiBS,UAA/CtB;MACA,IAAIH,aAAJ,EACEG,YAAY,CAAC,EAAEI,WAAH,CAAZJ,GAA8Ba,MAAM,CAACO,IAAI,EAAL,CAANP,GAAiBH,kBAA/CV;IACH;;IAEDqB,YAAY,IAAIvB,WAAhBuB;EAlEF,SAmESA,YAAY,GAAG,KAAKjD,+BAnE7B;;EAqEA,OAAO4B,YAAP;AA9FF;;AAiGAzC,MAAM,CAACmB,SAAPnB,CAAiBqE,wBAAjBrE,GAA4C,UAASqC,MAAT,EAAiBC,aAAjB,EAAgC;EAC1E,IAAME,WAAW,GAAG,KAAKT,qBAAzB;EACA,IAAMoB,kBAAkB,GAAG,IAAIX,WAA/B;EACA,IAAMc,MAAM,GAAG,KAAKgB,qBAApB;EACA,IAAM7B,YAAY,GAAG,KAAK8B,YAA1B;EACA,IAAMf,sBAAsB,GAAG,KAAKgB,sCAApC;EAEA,IAAI7B,MAAM,GAAG,CAAb;EACA,IAAIe,YAAY,GAAG,CAAnB;EACA,IAAIC,cAAc,GAAG,CAArB;EACA,IAAIC,eAAe,GAAG,CAAtB;EACA,IAAIf,WAAW,GAAG,CAAlB;EACA,IAAIiB,YAAY,GAAG,CAAnB;EACA,IAAIW,KAAK,GAAG,CAAZ;EACA,IAAIV,UAAU,GAAG,CAAjB;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;EACA,IAAIC,CAAC,GAAG,CAAR;;EAEA,GAAG;IACD,KACEtB,WAAW,GAAG,CADhB,EAEEA,WAAW,GAAG,KAAKhC,+BAFrB,GAIE;MACAyC,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwB,CAAxBA;MACAA,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwB,CAAxBA;MACAA,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwB,CAAxBA;;MAEA,IAAIhB,aAAJ,EAAmB;QACjBgB,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwB,CAAxBA;QACAE,sBAAsB,CAACX,WAAW,GAAG,CAAdA,GAAkB,CAAnB,CAAtBW,GAA8C,CAA9CA;MACD;IACF;;IAEDb,MAAM,GAAGH,WAATG;;IAEA,GAAG;MACDe,YAAY,GAAG,IAAIC,cAAJ,GAAqBC,eAApCF;MACAK,UAAU,GAAGvD,IAAI,CAAC4D,GAAL5D,CAASmC,MAATnC,EAAiBkD,YAAjBlD,CAAbuD;MACAU,KAAK,GAAGd,cAARc;;MAEA,KACE5B,WAAW,GAAG,CADhB,EAEEA,WAAW,GAAG,KAAKhC,+BAFrB,GAIE;QACAmD,CAAC,GAAG3B,MAAM,CAACoC,KAAK,EAAN,CAAVT;QACAC,CAAC,GAAG5B,MAAM,CAACoC,KAAK,EAAN,CAAVR;QACAC,CAAC,GAAG7B,MAAM,CAACoC,KAAK,EAAN,CAAVP;QACAC,CAAC,GAAG7B,aAAa,GAAGD,MAAM,CAACoC,KAAK,EAAN,CAAT,GAAqB,GAAtCN,CAJA,CAKA;;QACAb,MAAM,CAACT,WAAW,EAAZ,CAANS,IAAyB,CAACa,CAAC,GAAGH,CAAH,GAAO,CAAT,IAAcD,UAAvCT;QACAA,MAAM,CAACT,WAAW,EAAZ,CAANS,IAAyB,CAACa,CAAC,GAAGF,CAAH,GAAO,CAAT,IAAcF,UAAvCT;QACAA,MAAM,CAACT,WAAW,EAAZ,CAANS,IAAyB,CAACa,CAAC,GAAGD,CAAH,GAAO,CAAT,IAAcH,UAAvCT;;QAEA,IAAIhB,aAAJ,EAAmB;UACjBgB,MAAM,CAACT,WAAW,EAAZ,CAANS,IAAyBa,CAAC,GAAGJ,UAA7BT;UACAE,sBAAsB,CAACX,WAAW,GAAG,CAAdA,GAAkB,CAAnB,CAAtBW,IAA+CW,CAAC,GAAGJ,UAAH,GAAgB,CAAhEP;QACD;MACF;;MAED,IAAIb,MAAM,IAAIe,YAAd,EAA4B;QAC1BC,cAAc,GAAGc,KAAjBd;QACAC,eAAe,GAAGD,cAAlBC;QACAjB,MAAM,IAAIe,YAAVf;MAHF,OAIO;QACLiB,eAAe,IAAIjB,MAAnBiB;QACA;MACD;IAhCH,SAiCSjB,MAAM,GAAG,CAATA,IAAcgB,cAAc,GAAG,KAAK3C,mBAjC7C;;IAmCA,KACE6B,WAAW,GAAG,CADhB,EAEEA,WAAW,GAAG,KAAKhC,+BAFrB,GAIE;MACA8B,MAAM,GAAGL,aAAa,GAAGkB,sBAAsB,CAACX,WAAW,GAAG,CAAf,CAAzB,GAA6C,CAAnEF;MACAoB,UAAU,GAAGzB,aAAa,GACtBK,MAAM,GACJ,IAAIA,MADA,GAEJ,CAHoB,GAItBQ,kBAJJY;MAKAtB,YAAY,CAACqB,YAAY,EAAb,CAAZrB,GAA+BjC,IAAI,CAACkE,KAALlE,CAC7B8C,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwBS,UADKvD,CAA/BiC;MAGAA,YAAY,CAACqB,YAAY,EAAb,CAAZrB,GAA+BjC,IAAI,CAACkE,KAALlE,CAC7B8C,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwBS,UADKvD,CAA/BiC;MAGAA,YAAY,CAACqB,YAAY,EAAb,CAAZrB,GAA+BjC,IAAI,CAACkE,KAALlE,CAC7B8C,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwBS,UADKvD,CAA/BiC;;MAIA,IAAIH,aAAJ,EAAmB;QACjBG,YAAY,CAACqB,YAAY,EAAb,CAAZrB,GAA+BjC,IAAI,CAACkE,KAALlE,CAC7B8C,MAAM,CAACT,WAAW,EAAZ,CAANS,GAAwBH,kBADK3C,CAA/BiC;MAGD;IACF;EA/EH,SAgFSqB,YAAY,GAAG,KAAK7C,eAhF7B;;EAkFA,OAAOwB,YAAP;AAtGF;;AAyGAzC,MAAM,CAACmB,SAAPnB,CAAiB2B,0BAAjB3B,GAA8C,UAASqC,MAAT,EAAiB;EAC7D,OAAO,KAAKD,mCAAL,CAAyCC,MAAzC,EAAiD,KAAjD,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiB0B,2BAAjB1B,GAA+C,UAASqC,MAAT,EAAiB;EAC9D,OAAO,KAAKD,mCAAL,CAAyCC,MAAzC,EAAiD,IAAjD,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiB6B,cAAjB7B,GAAkC,UAASqC,MAAT,EAAiB;EACjD,OAAO,KAAKa,uBAAL,CAA6Bb,MAA7B,EAAqC,KAArC,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiB4B,eAAjB5B,GAAmC,UAASqC,MAAT,EAAiB;EAClD,OAAO,KAAKa,uBAAL,CAA6Bb,MAA7B,EAAqC,IAArC,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiBiC,wBAAjBjC,GAA4C,UAASqC,MAAT,EAAiB;EAC3D,IAAMG,WAAW,GAAG,KAAKT,qBAAzB;EACA,IAAMU,YAAY,GAAG,KAAK8B,YAA1B;EAEA,IAAI5B,MAAM,GAAG,CAAb;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAIC,WAAW,GAAG,CAAlB;EACA,IAAI8B,sBAAsB,GAAG,CAA7B;EACA,IAAIC,uBAAuB,GAAG,CAA9B;EACA,IAAI9B,WAAW,GAAG,CAAlB;EACA,IAAIC,YAAY,GAAG,CAAnB;EACA,IAAI8B,iCAAJ,CAX2D,CAa3D;;EACA,OAAOlC,MAAM,GAAG,IAAI,CAApB,EAAuBA,MAAM,IAAIH,WAAjC,EAA8C;IAC5C,KACEK,WAAW,GAAG,CADhB,EAEEA,WAAW,GAAG,KAAKhC,+BAFrB,GAIE;MACA4B,YAAY,CAACG,WAAW,EAAZ,CAAZH,GAA8BjC,IAAI,CAACkE,KAALlE,CAAW6B,MAAM,CAACQ,WAAW,EAAZ,CAAjBrC,CAA9BiC;IACD;EArBwD,EAwB3D;;;EACAE,MAAM,IAAI,IAAI,CAAdA;;EAEA,KACEkC,iCAAiC,GAAG,KAAK3E,cAAL,GAAsB,CAD5D,EAEEyC,MAAM,GAAGkC,iCAFX,EAGElC,MAAM,IAAIH,WAHZ,EAIE;IACA;IACAO,YAAY,GAAGJ,MAAM,GAAG,CAAxBI;IACAD,WAAW,GAAG,IAAIC,YAAlBD,CAHA,CAIA;;IACA6B,sBAAsB,GACpBnE,IAAI,CAACE,KAALF,CAAWmC,MAAXnC,IAAqB,KAAKK,+BAD5B8D;IAEAC,uBAAuB,GACrBD,sBAAsB,GAAG,KAAK9D,+BADhC+D;;IAEA,KACE/B,WAAW,GAAG,CADhB,EAEEA,WAAW,GAAG,KAAKhC,+BAFrB,EAGE,EAAEgC,WAHJ,EAIE;MACAJ,YAAY,CAACG,WAAW,EAAZ,CAAZH,GAA8BjC,IAAI,CAACkE,KAALlE,CAC5B6B,MAAM,CAACsC,sBAAsB,EAAvB,CAANtC,GAAmCS,WAAnCT,GACEA,MAAM,CAACuC,uBAAuB,EAAxB,CAANvC,GAAoCU,YAFVvC,CAA9BiC;IAID;EAjDwD,EAoD3D;;;EACA,OAAOG,WAAW,GAAG,KAAK3B,eAA1B,EAA2C;IACzC,KACE4B,WAAW,GAAG,CAAdA,EACE8B,sBAAsB,GACpBE,iCAAiC,GACjC,KAAKhE,+BAJX,EAKEgC,WAAW,GAAG,KAAKhC,+BALrB,EAME,EAAEgC,WANJ,EAOE;MACAJ,YAAY,CAACG,WAAW,EAAZ,CAAZH,GAA8BjC,IAAI,CAACkE,KAALlE,CAC5B6B,MAAM,CAACsC,sBAAsB,EAAvB,CADsBnE,CAA9BiC;IAGD;EACF;;EAED,OAAOA,YAAP;AApEF;;AAuEAzC,MAAM,CAACmB,SAAPnB,CAAiBmC,eAAjBnC,GAAmC,UAASqC,MAAT,EAAiB;EAClD,OAAO,KAAKgC,wBAAL,CAA8BhC,MAA9B,EAAsC,KAAtC,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiBkC,gBAAjBlC,GAAoC,UAASqC,MAAT,EAAiB;EACnD,OAAO,KAAKgC,wBAAL,CAA8BhC,MAA9B,EAAsC,IAAtC,CAAP;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiB8E,MAAjB9E,GAA0B,UAASqC,MAAT,EAAiB;EACzC,KAAK9B,cAAL,CAAoB,KAAKuB,YAAL,CAAkB,KAAKR,WAAL,CAAiBe,MAAjB,CAAlB,CAApB;AADF;;AAIArC,MAAM,CAACmB,SAAPnB,CAAiBuB,aAAjBvB,GAAiC,UAASqC,MAAT,EAAiB;EAChD;EACA,OAAOA,MAAP;AAFF;;AAKArC,MAAM,CAACmB,SAAPnB,CAAiByB,0BAAjBzB,GAA8C,UAAS+E,YAAT,EAAuB;EACnE;EACA,KAAKrC,WAAL,GAAmB,KAAKsC,mBAAL,CAAyB,KAAKhE,mBAA9B,CAAnB;;EAEA,IAAI,CAAC+D,YAAL,EAAmB;IACjB,KAAKxB,oBAAL,GAA4B,KAAKyB,mBAAL,CAC1B,KAAKjE,kCADqB,CAA5B;;IAIA,IAAI,KAAKJ,aAAL,GAAqB,CAAzB,EAA4B;MAC1B,KAAK8C,qCAAL,GAA6C,KAAKwB,qBAAL,CAC3C,KAAK/E,cADsC,CAA7C;IAGD;EACF;AAdH;;AAiBAF,MAAM,CAACmB,SAAPnB,CAAiBgC,2BAAjBhC,GAA+C,UAAS+E,YAAT,EAAuB;EACpE;EACA,KAAKR,YAAL,GAAoB,KAAKW,mBAAL,CAAyB,KAAKjE,eAA9B,CAApB;;EAEA,IAAI,CAAC8D,YAAL,EAAmB;IACjB,KAAKT,qBAAL,GAA6B,KAAKU,mBAAL,CAC3B,KAAKnE,+BADsB,CAA7B;;IAIA,IAAI,KAAKF,aAAL,GAAqB,CAAzB,EAA4B;MAC1B,KAAK6D,sCAAL,GAA8C,KAAKS,qBAAL,CAC5C,KAAK9E,WADuC,CAA9C;IAGD;EACF;AAdH;;AAiBAH,MAAM,CAACmB,SAAPnB,CAAiBgF,mBAAjBhF,GAAuC,UAASmF,YAAT,EAAuB;EAC5D;EACA,IAAI;IACF,OAAO,IAAIC,YAAJ,CAAiBD,YAAjB,CAAP;EADF,EAEE,OAAOE,KAAP,EAAc;IACd,OAAO,EAAP;EACD;AANH;;AASArF,MAAM,CAACmB,SAAPnB,CAAiBiF,qBAAjBjF,GAAyC,UAASmF,YAAT,EAAuB;EAC9D;EACA,IAAI;IACF,OAAO,IAAIG,YAAJ,CAAiBH,YAAjB,CAAP;EADF,EAEE,OAAOE,KAAP,EAAc;IACd,OAAO,EAAP;EACD;AANH;;AASArF,MAAM,CAACmB,SAAPnB,CAAiBkF,mBAAjBlF,GAAuC,UAASmF,YAAT,EAAuB;EAC5D;EACA,IAAI;IACF,OAAO,IAAII,UAAJ,CAAeJ,YAAf,CAAP;EADF,EAEE,OAAOE,KAAP,EAAc;IACd,OAAO,EAAP;EACD;AANH;;AASAG,MAAM,CAACC,OAAPD,GAAiBxF,MAAjBwF","names":["Resize","widthOriginal","heightOriginal","targetWidth","targetHeight","blendAlpha","interpolationPass","resizeCallback","Math","abs","floor","colorChannels","Boolean","targetWidthMultipliedByChannels","originalWidthMultipliedByChannels","originalHeightMultipliedByChannels","widthPassResultSize","finalResultSize","initialize","prototype","configurePasses","Error","resizeWidth","bypassResizer","ratioWeightWidthPass","initializeFirstPassBuffers","resizeWidthInterpolatedRGBA","resizeWidthInterpolatedRGB","resizeWidthRGBA","resizeWidthRGB","resizeHeight","ratioWeightHeightPass","initializeSecondPassBuffers","resizeHeightInterpolated","resizeHeightRGBA","resizeHeightRGB","_resizeWidthInterpolatedRGBChannels","buffer","fourthChannel","channelsNum","ratioWeight","outputBuffer","widthBuffer","weight","finalOffset","pixelOffset","firstWeight","secondWeight","targetPosition","interpolationWidthSourceReadStop","_resizeWidthRGBChannels","ratioWeightDivisor","nextLineOffsetOriginalWidth","nextLineOffsetTargetWidth","output","outputWidthWorkBench","trustworthyColorsCount","outputWidthWorkBenchOpaquePixelsCount","amountToNext","actualPosition","currentPosition","line","outputOffset","multiplier","r","g","b","a","min","_resizeHeightRGBChannels","outputHeightWorkBench","heightBuffer","outputHeightWorkBenchOpaquePixelsCount","caret","round","pixelOffsetAccumulated","pixelOffsetAccumulated2","interpolationHeightSourceReadStop","resize","BILINEARAlgo","generateFloatBuffer","generateFloat64Buffer","generateUint8Buffer","bufferLength","Float32Array","error","Float64Array","Uint8Array","module","exports"],"sources":["C:\\Users\\khaym\\Desktop\\finalproject\\Inventory-Front-End\\node_modules\\@jimp\\plugin-resize\\src\\modules\\resize.js"],"sourcesContent":["// JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(\n  widthOriginal,\n  heightOriginal,\n  targetWidth,\n  targetHeight,\n  blendAlpha,\n  interpolationPass,\n  resizeCallback\n) {\n  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n  this.colorChannels = blendAlpha ? 4 : 3;\n  this.interpolationPass = Boolean(interpolationPass);\n  this.resizeCallback =\n    typeof resizeCallback === 'function' ? resizeCallback : function() {};\n\n  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n  this.originalWidthMultipliedByChannels =\n    this.widthOriginal * this.colorChannels;\n  this.originalHeightMultipliedByChannels =\n    this.heightOriginal * this.colorChannels;\n  this.widthPassResultSize =\n    this.targetWidthMultipliedByChannels * this.heightOriginal;\n  this.finalResultSize =\n    this.targetWidthMultipliedByChannels * this.targetHeight;\n  this.initialize();\n}\n\nResize.prototype.initialize = function() {\n  // Perform some checks:\n  if (\n    this.widthOriginal > 0 &&\n    this.heightOriginal > 0 &&\n    this.targetWidth > 0 &&\n    this.targetHeight > 0\n  ) {\n    this.configurePasses();\n  } else {\n    throw new Error('Invalid settings specified for the resizer.');\n  }\n};\n\nResize.prototype.configurePasses = function() {\n  if (this.widthOriginal === this.targetWidth) {\n    // Bypass the width resizer pass:\n    this.resizeWidth = this.bypassResizer;\n  } else {\n    // Setup the width resizer pass:\n    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n      this.initializeFirstPassBuffers(true);\n      this.resizeWidth =\n        this.colorChannels === 4\n          ? this.resizeWidthInterpolatedRGBA\n          : this.resizeWidthInterpolatedRGB;\n    } else {\n      this.initializeFirstPassBuffers(false);\n      this.resizeWidth =\n        this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n    }\n  }\n\n  if (this.heightOriginal === this.targetHeight) {\n    // Bypass the height resizer pass:\n    this.resizeHeight = this.bypassResizer;\n  } else {\n    // Setup the height resizer pass:\n    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n      this.initializeSecondPassBuffers(true);\n      this.resizeHeight = this.resizeHeightInterpolated;\n    } else {\n      this.initializeSecondPassBuffers(false);\n      this.resizeHeight =\n        this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n    }\n  }\n};\n\nResize.prototype._resizeWidthInterpolatedRGBChannels = function(\n  buffer,\n  fourthChannel\n) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const outputBuffer = this.widthBuffer;\n\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let targetPosition;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (\n    targetPosition = 0;\n    weight < 1 / 3;\n    targetPosition += channelsNum, weight += ratioWeight\n  ) {\n    for (\n      finalOffset = targetPosition, pixelOffset = 0;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n  let interpolationWidthSourceReadStop;\n\n  for (\n    interpolationWidthSourceReadStop = this.widthOriginal - 1;\n    weight < interpolationWidthSourceReadStop;\n    targetPosition += channelsNum, weight += ratioWeight\n  ) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    for (\n      finalOffset = targetPosition,\n        pixelOffset = Math.floor(weight) * channelsNum;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset + 0] =\n        buffer[pixelOffset + 0] * firstWeight +\n        buffer[pixelOffset + channelsNum + 0] * secondWeight;\n      outputBuffer[finalOffset + 1] =\n        buffer[pixelOffset + 1] * firstWeight +\n        buffer[pixelOffset + channelsNum + 1] * secondWeight;\n      outputBuffer[finalOffset + 2] =\n        buffer[pixelOffset + 2] * firstWeight +\n        buffer[pixelOffset + channelsNum + 2] * secondWeight;\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] =\n          buffer[pixelOffset + 3] * firstWeight +\n          buffer[pixelOffset + channelsNum + 3] * secondWeight;\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  for (\n    interpolationWidthSourceReadStop =\n      this.originalWidthMultipliedByChannels - channelsNum;\n    targetPosition < this.targetWidthMultipliedByChannels;\n    targetPosition += channelsNum\n  ) {\n    for (\n      finalOffset = targetPosition,\n        pixelOffset = interpolationWidthSourceReadStop;\n      finalOffset < this.widthPassResultSize;\n      pixelOffset += this.originalWidthMultipliedByChannels,\n        finalOffset += this.targetWidthMultipliedByChannels\n    ) {\n      outputBuffer[finalOffset] = buffer[pixelOffset];\n      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n      if (fourthChannel)\n        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {\n  const channelsNum = fourthChannel ? 4 : 3;\n  const ratioWeight = this.ratioWeightWidthPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const nextLineOffsetOriginalWidth =\n    this.originalWidthMultipliedByChannels - channelsNum + 1;\n  const nextLineOffsetTargetWidth =\n    this.targetWidthMultipliedByChannels - channelsNum + 1;\n  const output = this.outputWidthWorkBench;\n  const outputBuffer = this.widthBuffer;\n  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let line = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n\n  do {\n    for (line = 0; line < this.originalHeightMultipliedByChannels; ) {\n      output[line++] = 0;\n      output[line++] = 0;\n      output[line++] = 0;\n      if (fourthChannel) {\n        output[line++] = 0;\n        trustworthyColorsCount[line / channelsNum - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      for (\n        line = 0, pixelOffset = actualPosition;\n        line < this.originalHeightMultipliedByChannels;\n        pixelOffset += nextLineOffsetOriginalWidth\n      ) {\n        r = buffer[pixelOffset];\n        g = buffer[++pixelOffset];\n        b = buffer[++pixelOffset];\n        a = fourthChannel ? buffer[++pixelOffset] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[line++] += (a ? r : 0) * multiplier;\n        output[line++] += (a ? g : 0) * multiplier;\n        output[line++] += (a ? b : 0) * multiplier;\n        if (fourthChannel) {\n          output[line++] += a * multiplier;\n          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition += channelsNum;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (\n      weight > 0 &&\n      actualPosition < this.originalWidthMultipliedByChannels\n    );\n\n    for (\n      line = 0, pixelOffset = outputOffset;\n      line < this.originalHeightMultipliedByChannels;\n      pixelOffset += nextLineOffsetTargetWidth\n    ) {\n      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n      multiplier = fourthChannel\n        ? weight\n          ? 1 / weight\n          : 0\n        : ratioWeightDivisor;\n      outputBuffer[pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      outputBuffer[++pixelOffset] = output[line++] * multiplier;\n      if (fourthChannel)\n        outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n    }\n\n    outputOffset += channelsNum;\n  } while (outputOffset < this.targetWidthMultipliedByChannels);\n\n  return outputBuffer;\n};\n\nResize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const ratioWeightDivisor = 1 / ratioWeight;\n  const output = this.outputHeightWorkBench;\n  const outputBuffer = this.heightBuffer;\n  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n\n  let weight = 0;\n  let amountToNext = 0;\n  let actualPosition = 0;\n  let currentPosition = 0;\n  let pixelOffset = 0;\n  let outputOffset = 0;\n  let caret = 0;\n  let multiplier = 1;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let a = 0;\n\n  do {\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n      output[pixelOffset++] = 0;\n\n      if (fourthChannel) {\n        output[pixelOffset++] = 0;\n        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n      }\n    }\n\n    weight = ratioWeight;\n\n    do {\n      amountToNext = 1 + actualPosition - currentPosition;\n      multiplier = Math.min(weight, amountToNext);\n      caret = actualPosition;\n\n      for (\n        pixelOffset = 0;\n        pixelOffset < this.targetWidthMultipliedByChannels;\n\n      ) {\n        r = buffer[caret++];\n        g = buffer[caret++];\n        b = buffer[caret++];\n        a = fourthChannel ? buffer[caret++] : 255;\n        // Ignore RGB values if pixel is completely transparent\n        output[pixelOffset++] += (a ? r : 0) * multiplier;\n        output[pixelOffset++] += (a ? g : 0) * multiplier;\n        output[pixelOffset++] += (a ? b : 0) * multiplier;\n\n        if (fourthChannel) {\n          output[pixelOffset++] += a * multiplier;\n          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n        }\n      }\n\n      if (weight >= amountToNext) {\n        actualPosition = caret;\n        currentPosition = actualPosition;\n        weight -= amountToNext;\n      } else {\n        currentPosition += weight;\n        break;\n      }\n    } while (weight > 0 && actualPosition < this.widthPassResultSize);\n\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n      multiplier = fourthChannel\n        ? weight\n          ? 1 / weight\n          : 0\n        : ratioWeightDivisor;\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n      outputBuffer[outputOffset++] = Math.round(\n        output[pixelOffset++] * multiplier\n      );\n\n      if (fourthChannel) {\n        outputBuffer[outputOffset++] = Math.round(\n          output[pixelOffset++] * ratioWeightDivisor\n        );\n      }\n    }\n  } while (outputOffset < this.finalResultSize);\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeWidthInterpolatedRGB = function(buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {\n  return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeWidthRGB = function(buffer) {\n  return this._resizeWidthRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeWidthRGBA = function(buffer) {\n  return this._resizeWidthRGBChannels(buffer, true);\n};\n\nResize.prototype.resizeHeightInterpolated = function(buffer) {\n  const ratioWeight = this.ratioWeightHeightPass;\n  const outputBuffer = this.heightBuffer;\n\n  let weight = 0;\n  let finalOffset = 0;\n  let pixelOffset = 0;\n  let pixelOffsetAccumulated = 0;\n  let pixelOffsetAccumulated2 = 0;\n  let firstWeight = 0;\n  let secondWeight = 0;\n  let interpolationHeightSourceReadStop;\n\n  // Handle for only one interpolation input being valid for start calculation:\n  for (; weight < 1 / 3; weight += ratioWeight) {\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n\n    ) {\n      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n    }\n  }\n\n  // Adjust for overshoot of the last pass's counter:\n  weight -= 1 / 3;\n\n  for (\n    interpolationHeightSourceReadStop = this.heightOriginal - 1;\n    weight < interpolationHeightSourceReadStop;\n    weight += ratioWeight\n  ) {\n    // Calculate weightings:\n    secondWeight = weight % 1;\n    firstWeight = 1 - secondWeight;\n    // Interpolate:\n    pixelOffsetAccumulated =\n      Math.floor(weight) * this.targetWidthMultipliedByChannels;\n    pixelOffsetAccumulated2 =\n      pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n    for (\n      pixelOffset = 0;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n      ++pixelOffset\n    ) {\n      outputBuffer[finalOffset++] = Math.round(\n        buffer[pixelOffsetAccumulated++] * firstWeight +\n          buffer[pixelOffsetAccumulated2++] * secondWeight\n      );\n    }\n  }\n\n  // Handle for only one interpolation input being valid for end calculation:\n  while (finalOffset < this.finalResultSize) {\n    for (\n      pixelOffset = 0,\n        pixelOffsetAccumulated =\n          interpolationHeightSourceReadStop *\n          this.targetWidthMultipliedByChannels;\n      pixelOffset < this.targetWidthMultipliedByChannels;\n      ++pixelOffset\n    ) {\n      outputBuffer[finalOffset++] = Math.round(\n        buffer[pixelOffsetAccumulated++]\n      );\n    }\n  }\n\n  return outputBuffer;\n};\n\nResize.prototype.resizeHeightRGB = function(buffer) {\n  return this._resizeHeightRGBChannels(buffer, false);\n};\n\nResize.prototype.resizeHeightRGBA = function(buffer) {\n  return this._resizeHeightRGBChannels(buffer, true);\n};\n\nResize.prototype.resize = function(buffer) {\n  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\n\nResize.prototype.bypassResizer = function(buffer) {\n  // Just return the buffer passed:\n  return buffer;\n};\n\nResize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {\n  // Initialize the internal width pass buffers:\n  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputWidthWorkBench = this.generateFloatBuffer(\n      this.originalHeightMultipliedByChannels\n    );\n\n    if (this.colorChannels > 3) {\n      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(\n        this.heightOriginal\n      );\n    }\n  }\n};\n\nResize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {\n  // Initialize the internal height pass buffers:\n  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n\n  if (!BILINEARAlgo) {\n    this.outputHeightWorkBench = this.generateFloatBuffer(\n      this.targetWidthMultipliedByChannels\n    );\n\n    if (this.colorChannels > 3) {\n      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(\n        this.targetWidth\n      );\n    }\n  }\n};\n\nResize.prototype.generateFloatBuffer = function(bufferLength) {\n  // Generate a float32 typed array buffer:\n  try {\n    return new Float32Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateFloat64Buffer = function(bufferLength) {\n  // Generate a float64 typed array buffer:\n  try {\n    return new Float64Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nResize.prototype.generateUint8Buffer = function(bufferLength) {\n  // Generate a uint8 typed array buffer:\n  try {\n    return new Uint8Array(bufferLength);\n  } catch (error) {\n    return [];\n  }\n};\n\nmodule.exports = Resize;\n"]},"metadata":{},"sourceType":"script"}