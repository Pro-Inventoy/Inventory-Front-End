{"ast":null,"code":"'use strict';\n\nvar interlaceUtils = require('./interlace');\n\nvar paethPredictor = require('./paeth-predictor');\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n\n  return byteWidth;\n}\n\nvar Filter = module.exports = function (bitmapInfo, dependencies) {\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n  this._imageIndex = 0;\n  this._images = [];\n\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  } else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  } // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n\n\n  if (depth === 8) {\n    this._xComparison = bpp;\n  } else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  } else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function () {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function (rawData, unfilteredLine, byteWidth) {\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function (rawData) {\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  } else {\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n  currentImage.lineIndex++;\n\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  } else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  } else {\n    this._lastLine = null;\n    this.complete();\n  }\n};","map":{"version":3,"names":["interlaceUtils","require","paethPredictor","getByteWidth","width","bpp","depth","byteWidth","Math","ceil","Filter","module","exports","bitmapInfo","dependencies","height","interlace","read","write","complete","_imageIndex","_images","passes","getImagePasses","i","length","push","lineIndex","_xComparison","prototype","start","_reverseFilterLine","bind","_unFilterType1","rawData","unfilteredLine","xComparison","xBiggerThan","x","rawByte","f1Left","_unFilterType2","lastLine","_lastLine","f2Up","_unFilterType3","f3Up","f3Left","f3Add","floor","_unFilterType4","f4Up","f4Left","f4UpLeft","f4Add","filter","currentImage","slice","Buffer","Error"],"sources":["C:/Users/khaym/Desktop/finalproject/Inventory-Front-End/node_modules/pngjs/lib/filter-parse.js"],"sourcesContent":["'use strict';\n\nvar interlaceUtils = require('./interlace');\nvar paethPredictor = require('./paeth-predictor');\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nvar Filter = module.exports = function(bitmapInfo, dependencies) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  }\n  else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  }\n  else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  }\n  else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function() {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {\n\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function(rawData) {\n\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  }\n  else {\n\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  }\n  else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  }\n  else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}