{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar Stream = require('stream');\n\nvar ChunkStream = module.exports = function () {\n  Stream.call(this);\n  this._buffers = [];\n  this._buffered = 0;\n  this._reads = [];\n  this._paused = false;\n  this._encoding = 'utf8';\n  this.writable = true;\n};\n\nutil.inherits(ChunkStream, Stream);\n\nChunkStream.prototype.read = function (length, callback) {\n  this._reads.push({\n    length: Math.abs(length),\n    // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function () {\n    this._process(); // its paused and there is not enought data then ask for more\n\n\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function (data, encoding) {\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  } else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n\n  this._buffered += dataBuffer.length;\n\n  this._process(); // ok if there are no more read requests\n\n\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function (data, encoding) {\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false; // already destroyed\n\n  if (!this._buffers) {\n    return;\n  } // enqueue or handle end\n\n\n  if (this._buffers.length === 0) {\n    this._end();\n  } else {\n    this._buffers.push(null);\n\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function () {\n  if (this._reads.length > 0) {\n    this.emit('error', new Error('Unexpected end of input'));\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function () {\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function (read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n  // first we need to peek into first buffer\n\n\n  var smallerBuf = this._buffers[0]; // ok there is more data than we need\n\n  if (smallerBuf.length > read.length) {\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n    read.func.call(this, smallerBuf.slice(0, read.length));\n  } else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n\n    this._buffers.shift(); // == smallerBuf\n\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function (read) {\n  this._reads.shift(); // == read\n\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length); // create buffer for all data\n\n  while (pos < read.length) {\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n    buf.copy(data, pos, 0, len);\n    pos += len; // last buffer wasn't used all so just slice it and leave\n\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  } // remove all used buffers\n\n\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function () {\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n      var read = this._reads[0]; // read any data (but no more than length)\n\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n      } else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n        this._processRead(read);\n      } else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && !this.writable) {\n      this._end();\n    }\n  } catch (ex) {\n    this.emit('error', ex);\n  }\n};","map":{"version":3,"names":["util","require","Stream","ChunkStream","module","exports","call","_buffers","_buffered","_reads","_paused","_encoding","writable","inherits","prototype","read","length","callback","push","Math","abs","allowLess","func","process","nextTick","_process","emit","bind","write","data","encoding","Error","dataBuffer","Buffer","isBuffer","end","_end","destroySoon","destroy","_processReadAllowingLess","shift","smallerBuf","slice","_processRead","pos","count","buf","len","min","copy","splice","ex"],"sources":["C:/Users/khaym/Desktop/finalproject/Inventory-Front-End/node_modules/pngjs/lib/chunkstream.js"],"sourcesContent":["'use strict';\n\n\nvar util = require('util');\nvar Stream = require('stream');\n\n\nvar ChunkStream = module.exports = function() {\n  Stream.call(this);\n\n  this._buffers = [];\n  this._buffered = 0;\n\n  this._reads = [];\n  this._paused = false;\n\n  this._encoding = 'utf8';\n  this.writable = true;\n};\nutil.inherits(ChunkStream, Stream);\n\n\nChunkStream.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length), // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function() {\n    this._process();\n\n    // its paused and there is not enought data then ask for more\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function(data, encoding) {\n\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  }\n  else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function(data, encoding) {\n\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  }\n  else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function() {\n\n  if (this._reads.length > 0) {\n    this.emit('error',\n      new Error('Unexpected end of input')\n    );\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function() {\n\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function(read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  var smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n\n    read.func.call(this, smallerBuf.slice(0, read.length));\n\n  }\n  else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function(read) {\n  this._reads.shift(); // == read\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function() {\n\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n\n      var read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n\n      }\n      else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      }\n      else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && !this.writable) {\n      this._end();\n    }\n  }\n  catch (ex) {\n    this.emit('error', ex);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}