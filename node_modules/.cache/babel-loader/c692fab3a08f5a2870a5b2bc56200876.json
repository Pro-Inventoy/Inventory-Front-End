{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\n\n\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  var rad = deg * Math.PI / 180;\n  var cosine = Math.cos(rad);\n  var sine = Math.sin(rad); // the final width and height will change if resize == true\n\n  var w = this.bitmap.width;\n  var h = this.bitmap.height;\n\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;\n    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1; // Ensure destination to have even size to a better result.\n\n    if (w % 2 !== 0) {\n      w++;\n    }\n\n    if (h % 2 !== 0) {\n      h++;\n    }\n\n    var c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n  }\n\n  var bW = this.bitmap.width;\n  var bH = this.bitmap.height;\n  var dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  function createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n\n  var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n\n  for (var y = 1; y <= bH; y++) {\n    for (var x = 1; x <= bW; x++) {\n      var cartesian = translate2Cartesian(x, y);\n      var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n      var dstIdx = bW * (y - 1) + x - 1 << 2;\n\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;\n        var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n\n  this.bitmap.data = dstBuffer;\n\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    var _x = bW / 2 - w / 2;\n\n    var _y = bH / 2 - h / 2;\n\n    this.crop(_x, _y, w, h);\n  }\n}\n\nvar _default = function _default() {\n  return {\n    /**\n     * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n     * @param {number} deg the number of degrees to rotate the image by\n     * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    rotate: function rotate(deg, mode, cb) {\n      // enable overloading\n      if (typeof mode === 'undefined' || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n      }\n\n      if (typeof deg !== 'number') {\n        return _utils.throwError.call(this, 'deg must be a number', cb);\n      }\n\n      if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n        return _utils.throwError.call(this, 'mode must be a boolean or a string', cb);\n      }\n\n      advancedRotate.call(this, deg, mode, cb);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["advancedRotate","deg","mode","rad","Math","PI","cosine","cos","sine","sin","w","bitmap","width","h","height","ceil","abs","c","cloneQuiet","scanQuiet","x","y","idx","data","writeUInt32BE","_background","max","resize","blit","bW","bH","dstBuffer","Buffer","alloc","length","createTranslationFunction","deltaX","deltaY","translate2Cartesian","translate2Screen","cartesian","source","dstIdx","srcIdx","pixelRGBA","readUInt32BE","crop","rotate","cb","throwError","call"],"sources":["C:\\Users\\khaym\\Desktop\\finalproject\\Inventory-Front-End\\node_modules\\@jimp\\plugin-rotate\\src\\index.js"],"sourcesContent":["import { throwError, isNodePattern } from '@jimp/utils';\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  const rad = (deg * Math.PI) / 180;\n  const cosine = Math.cos(rad);\n  const sine = Math.sin(rad);\n\n  // the final width and height will change if resize == true\n  let w = this.bitmap.width;\n  let h = this.bitmap.height;\n\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w =\n      Math.ceil(\n        Math.abs(this.bitmap.width * cosine) +\n          Math.abs(this.bitmap.height * sine)\n      ) + 1;\n    h =\n      Math.ceil(\n        Math.abs(this.bitmap.width * sine) +\n          Math.abs(this.bitmap.height * cosine)\n      ) + 1;\n    // Ensure destination to have even size to a better result.\n    if (w % 2 !== 0) {\n      w++;\n    }\n\n    if (h % 2 !== 0) {\n      h++;\n    }\n\n    const c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n\n    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n\n    this.blit(\n      c,\n      this.bitmap.width / 2 - c.bitmap.width / 2,\n      this.bitmap.height / 2 - c.bitmap.height / 2\n    );\n  }\n\n  const bW = this.bitmap.width;\n  const bH = this.bitmap.height;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  function createTranslationFunction(deltaX, deltaY) {\n    return function(x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n\n  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  const translate2Screen = createTranslationFunction(\n    bW / 2 + 0.5,\n    bH / 2 + 0.5\n  );\n\n  for (let y = 1; y <= bH; y++) {\n    for (let x = 1; x <= bW; x++) {\n      const cartesian = translate2Cartesian(x, y);\n      const source = translate2Screen(\n        cosine * cartesian.x - sine * cartesian.y,\n        cosine * cartesian.y + sine * cartesian.x\n      );\n      const dstIdx = (bW * (y - 1) + x - 1) << 2;\n\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n\n  this.bitmap.data = dstBuffer;\n\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    const x = bW / 2 - w / 2;\n    const y = bH / 2 - h / 2;\n    this.crop(x, y, w, h);\n  }\n}\n\nexport default () => ({\n  /**\n   * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n   * @param {number} deg the number of degrees to rotate the image by\n   * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === 'undefined' || mode === null) {\n      // e.g. image.resize(120);\n      // e.g. image.resize(120, null, cb);\n      // e.g. image.resize(120, undefined, cb);\n      mode = true;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      // e.g. image.resize(120, cb);\n      cb = mode;\n      mode = true;\n    }\n\n    if (typeof deg !== 'number') {\n      return throwError.call(this, 'deg must be a number', cb);\n    }\n\n    if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n      return throwError.call(this, 'mode must be a boolean or a string', cb);\n    }\n\n    advancedRotate.call(this, deg, mode, cb);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}