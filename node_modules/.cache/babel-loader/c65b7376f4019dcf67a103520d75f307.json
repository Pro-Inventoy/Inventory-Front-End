{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = composite;\n\nvar _utils = require(\"@jimp/utils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar compositeModes = _interopRequireWildcard(require(\"./composite-modes\"));\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nfunction composite(src, x, y) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var cb = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return _utils.throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return _utils.throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  var _options = options,\n      mode = _options.mode,\n      opacitySource = _options.opacitySource,\n      opacityDest = _options.opacityDest;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (typeof opacitySource !== 'number' || opacitySource < 0 || opacitySource > 1) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  var blendmode = compositeModes[mode]; // round input\n\n  x = Math.round(x);\n  y = Math.round(y);\n  var baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    var blended = blendmode({\n      r: this.bitmap.data[idx + 0] / 255,\n      g: this.bitmap.data[idx + 1] / 255,\n      b: this.bitmap.data[idx + 2] / 255,\n      a: this.bitmap.data[idx + 3] / 255\n    }, {\n      r: baseImage.bitmap.data[dstIdx + 0] / 255,\n      g: baseImage.bitmap.data[dstIdx + 1] / 255,\n      b: baseImage.bitmap.data[dstIdx + 2] / 255,\n      a: baseImage.bitmap.data[dstIdx + 3] / 255\n    }, opacitySource);\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);\n  });\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}","map":{"version":3,"mappings":"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","names":["composite","src","x","y","options","cb","constructor","throwError","call","mode","opacitySource","opacityDest","constants","BLEND_SOURCE_OVER","blendmode","compositeModes","Math","round","baseImage","opacity","scanQuiet","bitmap","width","height","sx","sy","idx","dstIdx","getPixelIndex","EDGE_CROP","blended","r","data","g","b","a","limit255"],"sources":["C:\\Users\\khaym\\Desktop\\finalproject\\Inventory-Front-End\\node_modules\\@jimp\\core\\src\\composite\\index.js"],"sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\nimport * as constants from '../constants';\n\nimport * as compositeModes from './composite-modes';\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default function composite(src, x, y, options = {}, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  let { mode, opacitySource, opacityDest } = options;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (\n    typeof opacitySource !== 'number' ||\n    opacitySource < 0 ||\n    opacitySource > 1\n  ) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  const blendmode = compositeModes[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n\n  const baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(\n    sx,\n    sy,\n    idx\n  ) {\n    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    const blended = blendmode(\n      {\n        r: this.bitmap.data[idx + 0] / 255,\n        g: this.bitmap.data[idx + 1] / 255,\n        b: this.bitmap.data[idx + 2] / 255,\n        a: this.bitmap.data[idx + 3] / 255\n      },\n      {\n        r: baseImage.bitmap.data[dstIdx + 0] / 255,\n        g: baseImage.bitmap.data[dstIdx + 1] / 255,\n        b: baseImage.bitmap.data[dstIdx + 2] / 255,\n        a: baseImage.bitmap.data[dstIdx + 3] / 255\n      },\n      opacitySource\n    );\n\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(\n      blended.r * 255\n    );\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(\n      blended.g * 255\n    );\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(\n      blended.b * 255\n    );\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(\n      blended.a * 255\n    );\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"script"}