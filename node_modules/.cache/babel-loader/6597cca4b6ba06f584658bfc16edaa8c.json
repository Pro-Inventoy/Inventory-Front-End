{"ast":null,"code":"/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\nmodule.exports = {\n  parseSections: function (stream, iterator) {\n    var len, markerType;\n    stream.setBigEndian(true); //stop reading the stream at the SOS (Start of Stream) marker,\n    //because its length is not stored in the header so we can't\n    //know where to jump to. The only marker after that is just EOI (End Of Image) anyway\n\n    while (stream.remainingLength() > 0 && markerType !== 0xDA) {\n      if (stream.nextUInt8() !== 0xFF) {\n        throw new Error('Invalid JPEG section offset');\n      }\n\n      markerType = stream.nextUInt8(); //don't read size from markers that have no datas\n\n      if (markerType >= 0xD0 && markerType <= 0xD9 || markerType === 0xDA) {\n        len = 0;\n      } else {\n        len = stream.nextUInt16() - 2;\n      }\n\n      iterator(markerType, stream.branch(0, len));\n      stream.skip(len);\n    }\n  },\n  //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator\n  getSizeFromSOFSection: function (stream) {\n    stream.skip(1);\n    return {\n      height: stream.nextUInt16(),\n      width: stream.nextUInt16()\n    };\n  },\n  getSectionName: function (markerType) {\n    var name, index;\n\n    switch (markerType) {\n      case 0xD8:\n        name = 'SOI';\n        break;\n\n      case 0xC4:\n        name = 'DHT';\n        break;\n\n      case 0xDB:\n        name = 'DQT';\n        break;\n\n      case 0xDD:\n        name = 'DRI';\n        break;\n\n      case 0xDA:\n        name = 'SOS';\n        break;\n\n      case 0xFE:\n        name = 'COM';\n        break;\n\n      case 0xD9:\n        name = 'EOI';\n        break;\n\n      default:\n        if (markerType >= 0xE0 && markerType <= 0xEF) {\n          name = 'APP';\n          index = markerType - 0xE0;\n        } else if (markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {\n          name = 'SOF';\n          index = markerType - 0xC0;\n        } else if (markerType >= 0xD0 && markerType <= 0xD7) {\n          name = 'RST';\n          index = markerType - 0xD0;\n        }\n\n        break;\n    }\n\n    var nameStruct = {\n      name: name\n    };\n\n    if (typeof index === 'number') {\n      nameStruct.index = index;\n    }\n\n    return nameStruct;\n  }\n};","map":{"version":3,"names":["module","exports","parseSections","stream","iterator","len","markerType","setBigEndian","remainingLength","nextUInt8","Error","nextUInt16","branch","skip","getSizeFromSOFSection","height","width","getSectionName","name","index","nameStruct"],"sources":["C:/Users/khaym/Desktop/finalproject/Inventory-Front-End/node_modules/exif-parser/lib/jpeg.js"],"sourcesContent":["/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */\n\nmodule.exports = {\n\tparseSections: function(stream, iterator) {\n\t\tvar len, markerType;\n\t\tstream.setBigEndian(true);\n\t\t//stop reading the stream at the SOS (Start of Stream) marker,\n\t\t//because its length is not stored in the header so we can't\n\t\t//know where to jump to. The only marker after that is just EOI (End Of Image) anyway\n\t\twhile(stream.remainingLength() > 0 && markerType !== 0xDA) {\n\t\t\tif(stream.nextUInt8() !== 0xFF) {\n\t\t\t\tthrow new Error('Invalid JPEG section offset');\n\t\t\t}\n\t\t\tmarkerType = stream.nextUInt8();\n\t\t\t//don't read size from markers that have no datas\n\t\t\tif((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tlen = stream.nextUInt16() - 2;\n\t\t\t}\n\t\t\titerator(markerType, stream.branch(0, len));\n\t\t\tstream.skip(len);\n\t\t}\n\t},\n\t//stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator\n\tgetSizeFromSOFSection: function(stream) {\n\t\tstream.skip(1);\n\t\treturn {\n\t\t\theight: stream.nextUInt16(),\n\t\t\twidth: stream.nextUInt16()\n\t\t};\n\t},\n\tgetSectionName: function(markerType) {\n\t\tvar name, index;\n\t\tswitch(markerType) {\n\t\t\tcase 0xD8: name = 'SOI'; break;\n\t\t\tcase 0xC4: name = 'DHT'; break;\n\t\t\tcase 0xDB: name = 'DQT'; break;\n\t\t\tcase 0xDD: name = 'DRI'; break;\n\t\t\tcase 0xDA: name = 'SOS'; break;\n\t\t\tcase 0xFE: name = 'COM'; break;\n\t\t\tcase 0xD9: name = 'EOI'; break;\n\t\t\tdefault:\n\t\t\t\tif(markerType >= 0xE0 && markerType <= 0xEF) {\n\t\t\t\t\tname = 'APP';\n\t\t\t\t\tindex = markerType - 0xE0;\n\t\t\t\t}\n\t\t\t\telse if(markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {\n\t\t\t\t\tname = 'SOF';\n\t\t\t\t\tindex = markerType - 0xC0;\n\t\t\t\t}\n\t\t\t\telse if(markerType >= 0xD0 && markerType <= 0xD7) {\n\t\t\t\t\tname = 'RST';\n\t\t\t\t\tindex = markerType - 0xD0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tvar nameStruct = {\n\t\t\tname: name\n\t\t};\n\t\tif(typeof index === 'number') {\n\t\t\tnameStruct.index = index;\n\t\t}\n\t\treturn nameStruct;\n\t}\n};"],"mappings":"AAAA;AAEAA,MAAM,CAACC,OAAP,GAAiB;EAChBC,aAAa,EAAE,UAASC,MAAT,EAAiBC,QAAjB,EAA2B;IACzC,IAAIC,GAAJ,EAASC,UAAT;IACAH,MAAM,CAACI,YAAP,CAAoB,IAApB,EAFyC,CAGzC;IACA;IACA;;IACA,OAAMJ,MAAM,CAACK,eAAP,KAA2B,CAA3B,IAAgCF,UAAU,KAAK,IAArD,EAA2D;MAC1D,IAAGH,MAAM,CAACM,SAAP,OAAuB,IAA1B,EAAgC;QAC/B,MAAM,IAAIC,KAAJ,CAAU,6BAAV,CAAN;MACA;;MACDJ,UAAU,GAAGH,MAAM,CAACM,SAAP,EAAb,CAJ0D,CAK1D;;MACA,IAAIH,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAArC,IAA8CA,UAAU,KAAK,IAAhE,EAAsE;QACrED,GAAG,GAAG,CAAN;MACA,CAFD,MAEO;QACNA,GAAG,GAAGF,MAAM,CAACQ,UAAP,KAAsB,CAA5B;MACA;;MACDP,QAAQ,CAACE,UAAD,EAAaH,MAAM,CAACS,MAAP,CAAc,CAAd,EAAiBP,GAAjB,CAAb,CAAR;MACAF,MAAM,CAACU,IAAP,CAAYR,GAAZ;IACA;EACD,CArBe;EAsBhB;EACAS,qBAAqB,EAAE,UAASX,MAAT,EAAiB;IACvCA,MAAM,CAACU,IAAP,CAAY,CAAZ;IACA,OAAO;MACNE,MAAM,EAAEZ,MAAM,CAACQ,UAAP,EADF;MAENK,KAAK,EAAEb,MAAM,CAACQ,UAAP;IAFD,CAAP;EAIA,CA7Be;EA8BhBM,cAAc,EAAE,UAASX,UAAT,EAAqB;IACpC,IAAIY,IAAJ,EAAUC,KAAV;;IACA,QAAOb,UAAP;MACC,KAAK,IAAL;QAAWY,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB,KAAK,IAAL;QAAWA,IAAI,GAAG,KAAP;QAAc;;MACzB;QACC,IAAGZ,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAvC,EAA6C;UAC5CY,IAAI,GAAG,KAAP;UACAC,KAAK,GAAGb,UAAU,GAAG,IAArB;QACA,CAHD,MAIK,IAAGA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAApC,IAA4CA,UAAU,KAAK,IAA3D,IAAmEA,UAAU,KAAK,IAAlF,IAA0FA,UAAU,KAAK,IAA5G,EAAkH;UACtHY,IAAI,GAAG,KAAP;UACAC,KAAK,GAAGb,UAAU,GAAG,IAArB;QACA,CAHI,MAIA,IAAGA,UAAU,IAAI,IAAd,IAAsBA,UAAU,IAAI,IAAvC,EAA6C;UACjDY,IAAI,GAAG,KAAP;UACAC,KAAK,GAAGb,UAAU,GAAG,IAArB;QACA;;QACD;IArBF;;IAuBA,IAAIc,UAAU,GAAG;MAChBF,IAAI,EAAEA;IADU,CAAjB;;IAGA,IAAG,OAAOC,KAAP,KAAiB,QAApB,EAA8B;MAC7BC,UAAU,CAACD,KAAX,GAAmBA,KAAnB;IACA;;IACD,OAAOC,UAAP;EACA;AA9De,CAAjB"},"metadata":{},"sourceType":"script"}